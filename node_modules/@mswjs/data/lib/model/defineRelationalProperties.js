"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
exports.__esModule = true;
exports.defineRelationalProperties = void 0;
var debug_1 = require("debug");
var glossary_1 = require("../glossary");
var executeQuery_1 = require("../query/executeQuery");
var first_1 = require("../utils/first");
var log = debug_1.debug('defineRelationalProperties');
function defineRelationalProperties(entity, initialValues, relations, db) {
    log('setting relations', relations, entity);
    var properties = Object.entries(relations).reduce(function (properties, _a) {
        var _b, _c;
        var _d = __read(_a, 2), property = _d[0], relation = _d[1];
        log("defining relational property \"" + entity.__type + "." + property + "\"", relation);
        if (!(property in initialValues))
            return properties;
        // Take the relational entity reference from the initial values.
        var entityRefs = [].concat(initialValues[property]);
        if (relation.unique) {
            log("verifying that the \"" + property + "\" relation is unique...");
            // Trying to look up an entity of the same type
            // that references the same relational entity.
            var existingEntities = executeQuery_1.executeQuery(entity[glossary_1.InternalEntityProperty.type], entity[glossary_1.InternalEntityProperty.primaryKey], {
                where: (_b = {},
                    _b[property] = (_c = {},
                        _c[relation.primaryKey] = {
                            "in": entityRefs.map(function (entityRef) {
                                return entityRef[entity[glossary_1.InternalEntityProperty.primaryKey]];
                            })
                        },
                        _c),
                    _b)
            }, db);
            log("existing entities that reference the same \"" + property + "\"", existingEntities);
            if (existingEntities.length > 0) {
                log("found a non-unique relational entity!");
                throw new Error("Failed to create a unique \"" + relation.modelName + "\" relation for \"" + entity.__type + "." + property + "\" (" + entity[entity[glossary_1.InternalEntityProperty.primaryKey]] + "): the provided entity is already used.");
            }
        }
        properties[property] = {
            enumerable: true,
            get: function () {
                log("get \"" + property + "\"", relation);
                var refValue = entityRefs.reduce(function (list, entityRef) {
                    var _a;
                    return list.concat(executeQuery_1.executeQuery(relation.modelName, relation.primaryKey, {
                        where: (_a = {},
                            _a[relation.primaryKey] = {
                                equals: entityRef[relation.primaryKey]
                            },
                            _a)
                    }, db));
                }, []);
                log("resolved \"" + relation.kind + "\" \"" + property + "\" to", refValue);
                return relation.kind === glossary_1.RelationKind.OneOf
                    ? first_1.first(refValue)
                    : refValue;
            }
        };
        return properties;
    }, {});
    Object.defineProperties(entity, properties);
}
exports.defineRelationalProperties = defineRelationalProperties;
