"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
exports.__esModule = true;
exports.factory = void 0;
var glossary_1 = require("./glossary");
var first_1 = require("./utils/first");
var executeQuery_1 = require("./query/executeQuery");
var parseModelDefinition_1 = require("./model/parseModelDefinition");
var createModel_1 = require("./model/createModel");
var invariant_1 = require("./utils/invariant");
var updateEntity_1 = require("./model/updateEntity");
var OperationError_1 = require("./errors/OperationError");
var Database_1 = require("./db/Database");
var generateRestHandlers_1 = require("./model/generateRestHandlers");
var generateGraphQLHandlers_1 = require("./model/generateGraphQLHandlers");
var sync_1 = require("./extensions/sync");
var removeInternalProperties_1 = require("./utils/removeInternalProperties");
/**
 * Create a database with the given models.
 */
function factory(dictionary) {
    var db = new Database_1.Database(dictionary);
    // Jnitialize database extensions.
    sync_1.sync(db);
    return Object.entries(dictionary).reduce(function (acc, _a) {
        var _b = __read(_a, 2), modelName = _b[0], props = _b[1];
        acc[modelName] = createModelApi(dictionary, modelName, props, db);
        return acc;
    }, {});
}
exports.factory = factory;
function createModelApi(dictionary, modelName, definition, db) {
    var parsedModel = parseModelDefinition_1.parseModelDefinition(dictionary, modelName, definition);
    var primaryKey = parsedModel.primaryKey;
    if (typeof primaryKey === 'undefined') {
        throw new OperationError_1.OperationError(OperationError_1.OperationErrorType.MissingPrimaryKey, "Failed to create a \"" + modelName + "\" model: none of the listed properties is marked as a primary key (" + Object.keys(definition).join() + ").");
    }
    var api = {
        create: function (initialValues) {
            if (initialValues === void 0) { initialValues = {}; }
            var entity = createModel_1.createModel(modelName, definition, parsedModel, initialValues, db);
            var entityId = entity[entity[glossary_1.InternalEntityProperty.primaryKey]];
            invariant_1.invariant(!entityId, "Failed to create a \"" + modelName + "\" entity: expected the primary key \"" + primaryKey + "\" to have a value, but got: " + entityId, new OperationError_1.OperationError(OperationError_1.OperationErrorType.MissingPrimaryKey));
            // Prevent creation of multiple entities with the same primary key value.
            invariant_1.invariant(db.has(modelName, entityId), "Failed to create a \"" + modelName + "\" entity: an entity with the same primary key \"" + entityId + "\" (\"" + entity[glossary_1.InternalEntityProperty.primaryKey] + "\") already exists.", new OperationError_1.OperationError(OperationError_1.OperationErrorType.DuplicatePrimaryKey));
            db.create(modelName, entity);
            return removeInternalProperties_1.removeInternalProperties(entity);
        },
        count: function (query) {
            if (!query) {
                return db.count(modelName);
            }
            var results = executeQuery_1.executeQuery(modelName, primaryKey, query, db);
            return results.length;
        },
        findFirst: function (query) {
            var results = executeQuery_1.executeQuery(modelName, primaryKey, query, db);
            var firstResult = first_1.first(results);
            invariant_1.invariant(query.strict && !firstResult, "Failed to execute \"findFirst\" on the \"" + modelName + "\" model: no entity found matching the query \"" + JSON.stringify(query.where) + "\".", new OperationError_1.OperationError(OperationError_1.OperationErrorType.EntityNotFound));
            return firstResult ? removeInternalProperties_1.removeInternalProperties(firstResult) : null;
        },
        findMany: function (query) {
            var results = executeQuery_1.executeQuery(modelName, primaryKey, query, db);
            invariant_1.invariant(query.strict && results.length === 0, "Failed to execute \"findMany\" on the \"" + modelName + "\" model: no entities found matching the query \"" + JSON.stringify(query.where) + "\".", new OperationError_1.OperationError(OperationError_1.OperationErrorType.EntityNotFound));
            return results.map(removeInternalProperties_1.removeInternalProperties);
        },
        getAll: function () {
            return db.listEntities(modelName).map(removeInternalProperties_1.removeInternalProperties);
        },
        update: function (_a) {
            var strict = _a.strict, query = __rest(_a, ["strict"]);
            var results = executeQuery_1.executeQuery(modelName, primaryKey, query, db);
            var prevRecord = first_1.first(results);
            if (!prevRecord) {
                invariant_1.invariant(strict, "Failed to execute \"update\" on the \"" + modelName + "\" model: no entity found matching the query \"" + JSON.stringify(query.where) + "\".", new OperationError_1.OperationError(OperationError_1.OperationErrorType.EntityNotFound));
                return null;
            }
            var nextRecord = updateEntity_1.updateEntity(prevRecord, query.data);
            if (nextRecord[prevRecord[glossary_1.InternalEntityProperty.primaryKey]] !==
                prevRecord[prevRecord[glossary_1.InternalEntityProperty.primaryKey]]) {
                invariant_1.invariant(db.has(modelName, nextRecord[prevRecord[glossary_1.InternalEntityProperty.primaryKey]]), "Failed to execute \"update\" on the \"" + modelName + "\" model: the entity with a primary key \"" + nextRecord[prevRecord[glossary_1.InternalEntityProperty.primaryKey]] + "\" (\"" + primaryKey + "\") already exists.", new OperationError_1.OperationError(OperationError_1.OperationErrorType.DuplicatePrimaryKey));
            }
            db.update(modelName, prevRecord, nextRecord);
            return removeInternalProperties_1.removeInternalProperties(nextRecord);
        },
        updateMany: function (_a) {
            var strict = _a.strict, query = __rest(_a, ["strict"]);
            var records = executeQuery_1.executeQuery(modelName, primaryKey, query, db);
            var updatedRecords = [];
            if (records.length === 0) {
                invariant_1.invariant(strict, "Failed to execute \"updateMany\" on the \"" + modelName + "\" model: no entities found matching the query \"" + JSON.stringify(query.where) + "\".", new OperationError_1.OperationError(OperationError_1.OperationErrorType.EntityNotFound));
                return null;
            }
            records.forEach(function (prevRecord) {
                var nextRecord = updateEntity_1.updateEntity(prevRecord, query.data);
                if (nextRecord[prevRecord[glossary_1.InternalEntityProperty.primaryKey]] !==
                    prevRecord[prevRecord[glossary_1.InternalEntityProperty.primaryKey]]) {
                    invariant_1.invariant(db.has(modelName, nextRecord[prevRecord[glossary_1.InternalEntityProperty.primaryKey]]), "Failed to execute \"updateMany\" on the \"" + modelName + "\" model: no entities found matching the query \"" + JSON.stringify(query.where) + "\".", new OperationError_1.OperationError(OperationError_1.OperationErrorType.EntityNotFound));
                }
                db.update(modelName, prevRecord, nextRecord);
                updatedRecords.push(nextRecord);
            });
            return updatedRecords.map(removeInternalProperties_1.removeInternalProperties);
        },
        "delete": function (_a) {
            var strict = _a.strict, query = __rest(_a, ["strict"]);
            var results = executeQuery_1.executeQuery(modelName, primaryKey, query, db);
            var record = first_1.first(results);
            if (!record) {
                invariant_1.invariant(strict, "Failed to execute \"delete\" on the \"" + modelName + "\" model: no entity found matching the query \"" + JSON.stringify(query.where) + "\".", new OperationError_1.OperationError(OperationError_1.OperationErrorType.EntityNotFound));
                return null;
            }
            db["delete"](modelName, record[record[glossary_1.InternalEntityProperty.primaryKey]]);
            return removeInternalProperties_1.removeInternalProperties(record);
        },
        deleteMany: function (_a) {
            var strict = _a.strict, query = __rest(_a, ["strict"]);
            var records = executeQuery_1.executeQuery(modelName, primaryKey, query, db);
            if (records.length === 0) {
                invariant_1.invariant(strict, "Failed to execute \"deleteMany\" on the \"" + modelName + "\" model: no entities found matching the query \"" + JSON.stringify(query.where) + "\".", new OperationError_1.OperationError(OperationError_1.OperationErrorType.EntityNotFound));
                return null;
            }
            records.forEach(function (record) {
                db["delete"](modelName, record[record[glossary_1.InternalEntityProperty.primaryKey]]);
            });
            return records.map(removeInternalProperties_1.removeInternalProperties);
        },
        toHandlers: function (type, baseUrl) {
            if (type === 'graphql') {
                return generateGraphQLHandlers_1.generateGraphQLHandlers(modelName, definition, api, baseUrl);
            }
            return generateRestHandlers_1.generateRestHandlers(modelName, definition, api, baseUrl);
        },
        toGraphQLSchema: function () {
            return generateGraphQLHandlers_1.generateGraphQLSchema(modelName, definition, api);
        }
    };
    return api;
}
